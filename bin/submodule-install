#!/bin/bash -e

# make cygwin bin as priority
export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH";

(set -o igncr) 2>/dev/null && set -o igncr; # cygwin encoding fix

# absolute path working directory
basecwd=${PWD}
# base script directory
basedir=`dirname "$0"`
# absolute path script directory
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

case `uname` in
  *CYGWIN*) basedir=`cygpath -w "$basedir"`;;
esac

# auto clone all submodules, prevent not-matched hash
# set ACCESS_TOKEN=github_personal_tokens
# usages: sh folder_this_repo/submodule-install

# get script path
SCRIPT=$(realpath "$0")
SCRIPTPATH=$(dirname "$SCRIPT")

# set default root
export ROOT="$(git rev-parse --show-toplevel)"

while test $# -gt 0; do
  case "$1" in
    -h|--help)
      echo "$package - attempt to install submodules"
      echo " "
      echo "$package [options] application [arguments]"
      echo " "
      echo "options:"
      echo "-h, --help                show brief help"
      echo "-o, --output-dir=DIR      specify a directory to install submodules"
      exit 0
      ;;
    -cwd)
      shift
      if test $# -gt 0; then
        export ROOT=$1
      else
        echo "no output dir specified"
        exit 1
      fi
      shift
      ;;
    --cwd*)
      export ROOT=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    *)
      break
      ;;
  esac
done

echo "installing submodules at $ROOT"

git -C "${REPO_PATH}" config -f .gitmodules --get-regexp '^submodule\..*\.path$' |
    while read -r KEY MODULE_PATH
    do
        # relative module path from root
        RELATIVE_MODULE_PATH="${ROOT}/${MODULE_PATH}"
        # cd git root dir
        cd ${ROOT}
        # If the module's path exists, remove it.
        # This is done b/c the module's path is currently
        # not a valid git repo and adding the submodule will cause an error.
        if [ -d "${RELATIVE_MODULE_PATH}" ]; then
            echo "deleting ${RELATIVE_MODULE_PATH}"
            rm -rf "${RELATIVE_MODULE_PATH}"
        fi

        NAME="$(echo "${KEY}" | sed 's/^submodule\.\(.*\)\.path$/\1/')"

        url_key="$(echo "${KEY}" | sed 's/\.path$/.url/')"
        branch_key="$(echo "${KEY}" | sed 's/\.path$/.branch/')"

        URL="$(git config -f .gitmodules --get "${url_key}")"
        BRANCH="$(git config -f .gitmodules --get "${branch_key}" || echo "master")"

        git -C "${REPO_PATH}" submodule add --force -b "${BRANCH}" --name "${NAME}" "${URL}" "${MODULE_PATH}" || echo "cannot add submodule ${MODULE_PATH}"

        repo=${URL#"https://github.com/"}
        URL_WITH_TOKEN="https://${ACCESS_TOKEN}@github.com/${repo}"

        echo "apply token for ${repo} at ${MODULE_PATH} branch ${BRANCH}"
        GIT_MODULES="${RELATIVE_MODULE_PATH}/.gitmodules"
        cd "${RELATIVE_MODULE_PATH}"
        git remote set-url origin "${URL_WITH_TOKEN}"
        git fetch --all
        git pull origin "${BRANCH}" -X theirs
        if [ -f "${GIT_MODULES}" ];
        then
          echo "${MODULE_PATH} has submodules"
          sh "${SCRIPT}" -cwd ${RELATIVE_MODULE_PATH}
        fi
    done

git -C "${REPO_PATH}" submodule update --init --recursive
